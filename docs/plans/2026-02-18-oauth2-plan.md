# StackPulse OAuth2 — Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Add OAuth2 authorization for GitHub, Vercel, and Sentry so users connect via browser-based OAuth instead of manually entering API keys.

**Architecture:** OAuth tokens (access_token, refresh_token, expires_at) are stored as encrypted JSON in the existing `connected_services.credentials` column — no DB migration needed. Two new API routes handle the authorize redirect and callback. The poll-service worker proactively refreshes Sentry tokens before they expire (1-hour TTL). GitHub and Vercel tokens are effectively long-lived and need no refresh.

**Tech Stack:** Next.js 16 App Router, TypeScript strict, Supabase, @upstash/qstash, Vitest.

---

## Task 1: OAuth State Helpers (`src/lib/oauth/state.ts`)

CSRF protection for the OAuth flow uses a random `state` value stored in a short-lived cookie. Label (display name) is also stored in a cookie so it survives the redirect.

**Files:**
- Create: `src/lib/oauth/state.ts`
- Create: `src/lib/oauth/__tests__/state.test.ts`

**Step 1: Write failing tests**

```typescript
// src/lib/oauth/__tests__/state.test.ts
import { describe, it, expect, vi, beforeEach } from 'vitest'

// Mock next/headers cookies
const mockCookies = new Map<string, string>()
vi.mock('next/headers', () => ({
  cookies: vi.fn(() => ({
    get: (key: string) => mockCookies.has(key) ? { value: mockCookies.get(key) } : undefined,
    set: (key: string, value: string) => { mockCookies.set(key, value) },
    delete: (key: string) => { mockCookies.delete(key) },
  })),
}))

import { generateState, setStateCookie, verifyStateCookie, setLabelCookie, getLabelCookie } from '../state'

describe('generateState', () => {
  it('returns a 64-char hex string', () => {
    const state = generateState()
    expect(state).toMatch(/^[0-9a-f]{64}$/)
  })

  it('generates unique values', () => {
    expect(generateState()).not.toBe(generateState())
  })
})

describe('state cookie round-trip', () => {
  beforeEach(() => { mockCookies.clear() })

  it('verifies matching state', async () => {
    await setStateCookie('abc123')
    const valid = await verifyStateCookie('abc123')
    expect(valid).toBe(true)
  })

  it('rejects mismatched state', async () => {
    await setStateCookie('abc123')
    const valid = await verifyStateCookie('wrong')
    expect(valid).toBe(false)
  })

  it('clears cookie after verification', async () => {
    await setStateCookie('abc123')
    await verifyStateCookie('abc123')
    const validAgain = await verifyStateCookie('abc123')
    expect(validAgain).toBe(false)
  })
})

describe('label cookie round-trip', () => {
  beforeEach(() => { mockCookies.clear() })

  it('retrieves stored label', async () => {
    await setLabelCookie('My GitHub')
    const label = await getLabelCookie()
    expect(label).toBe('My GitHub')
  })

  it('returns null when no label set', async () => {
    const label = await getLabelCookie()
    expect(label).toBeNull()
  })

  it('clears cookie after retrieval', async () => {
    await setLabelCookie('test')
    await getLabelCookie()
    const second = await getLabelCookie()
    expect(second).toBeNull()
  })
})
```

**Step 2: Run to confirm fail**

```bash
npx vitest run src/lib/oauth/__tests__/state.test.ts
```

Expected: FAIL — `../state` not found.

**Step 3: Implement**

```typescript
// src/lib/oauth/state.ts
import { cookies } from 'next/headers'
import { randomBytes } from 'crypto'

export function generateState(): string {
  return randomBytes(32).toString('hex')
}

export async function setStateCookie(state: string): Promise<void> {
  const jar = await cookies()
  jar.set('oauth_state', state, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'lax',
    maxAge: 60 * 10,
    path: '/',
  })
}

export async function verifyStateCookie(state: string): Promise<boolean> {
  const jar = await cookies()
  const stored = jar.get('oauth_state')?.value
  jar.delete('oauth_state')
  return stored === state
}

export async function setLabelCookie(label: string): Promise<void> {
  const jar = await cookies()
  jar.set('oauth_label', label, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'lax',
    maxAge: 60 * 10,
    path: '/',
  })
}

export async function getLabelCookie(): Promise<string | null> {
  const jar = await cookies()
  const label = jar.get('oauth_label')?.value ?? null
  jar.delete('oauth_label')
  return label
}
```

**Step 4: Run to confirm pass**

```bash
npx vitest run src/lib/oauth/__tests__/state.test.ts
```

Expected: All tests PASS.

**Step 5: Commit**

```bash
git add src/lib/oauth/state.ts src/lib/oauth/__tests__/state.test.ts
git commit -m "feat: add OAuth state and label cookie helpers"
```

---

## Task 2: OAuth Config (`src/lib/oauth/config.ts`)

Centralizes OAuth app credentials and endpoint URLs for each provider.

**Files:**
- Create: `src/lib/oauth/config.ts`
- Create: `src/lib/oauth/__tests__/config.test.ts`

**Step 1: Write failing test**

```typescript
// src/lib/oauth/__tests__/config.test.ts
import { describe, it, expect, beforeEach } from 'vitest'

describe('getOAuthConfig', () => {
  beforeEach(() => {
    process.env.GITHUB_CLIENT_ID = 'gh-client-id'
    process.env.GITHUB_CLIENT_SECRET = 'gh-secret'
    process.env.VERCEL_CLIENT_ID = 'v-client-id'
    process.env.VERCEL_CLIENT_SECRET = 'v-secret'
    process.env.SENTRY_CLIENT_ID = 's-client-id'
    process.env.SENTRY_CLIENT_SECRET = 's-secret'
    process.env.NEXT_PUBLIC_APP_URL = 'http://localhost:4567'
  })

  it('returns GitHub config', async () => {
    const { getOAuthConfig } = await import('../config')
    const config = getOAuthConfig('github')
    expect(config).not.toBeNull()
    expect(config!.authorizationUrl).toContain('github.com')
    expect(config!.scopes).toContain('read:user')
    expect(config!.redirectUri).toContain('/api/oauth/callback/github')
  })

  it('returns Vercel config', async () => {
    const { getOAuthConfig } = await import('../config')
    const config = getOAuthConfig('vercel')
    expect(config).not.toBeNull()
    expect(config!.authorizationUrl).toContain('vercel.com')
  })

  it('returns Sentry config with refresh scopes', async () => {
    const { getOAuthConfig } = await import('../config')
    const config = getOAuthConfig('sentry')
    expect(config).not.toBeNull()
    expect(config!.scopes).toContain('project:read')
    expect(config!.supportsRefresh).toBe(true)
  })

  it('returns null for unknown provider', async () => {
    const { getOAuthConfig } = await import('../config')
    expect(getOAuthConfig('unknown')).toBeNull()
  })
})
```

**Step 2: Run to confirm fail**

```bash
npx vitest run src/lib/oauth/__tests__/config.test.ts
```

**Step 3: Implement**

```typescript
// src/lib/oauth/config.ts
export interface OAuthProviderConfig {
  clientId: string
  clientSecret: string
  authorizationUrl: string
  tokenUrl: string
  scopes: string[]
  redirectUri: string
  supportsRefresh: boolean
}

function getAppUrl(): string {
  return process.env.NEXT_PUBLIC_APP_URL ?? 'http://localhost:4567'
}

export function getOAuthConfig(providerId: string): OAuthProviderConfig | null {
  const appUrl = getAppUrl()

  const configs: Record<string, OAuthProviderConfig> = {
    github: {
      clientId: process.env.GITHUB_CLIENT_ID ?? '',
      clientSecret: process.env.GITHUB_CLIENT_SECRET ?? '',
      authorizationUrl: 'https://github.com/login/oauth/authorize',
      tokenUrl: 'https://github.com/login/oauth/access_token',
      scopes: ['read:user'],
      redirectUri: `${appUrl}/api/oauth/callback/github`,
      supportsRefresh: false,
    },
    vercel: {
      clientId: process.env.VERCEL_CLIENT_ID ?? '',
      clientSecret: process.env.VERCEL_CLIENT_SECRET ?? '',
      authorizationUrl: 'https://vercel.com/oauth/authorize',
      tokenUrl: 'https://api.vercel.com/v2/oauth/access_token',
      scopes: [],
      redirectUri: `${appUrl}/api/oauth/callback/vercel`,
      supportsRefresh: false,
    },
    sentry: {
      clientId: process.env.SENTRY_CLIENT_ID ?? '',
      clientSecret: process.env.SENTRY_CLIENT_SECRET ?? '',
      authorizationUrl: 'https://sentry.io/oauth/authorize/',
      tokenUrl: 'https://sentry.io/oauth/token/',
      scopes: ['project:read', 'org:read', 'event:read'],
      redirectUri: `${appUrl}/api/oauth/callback/sentry`,
      supportsRefresh: true,
    },
  }

  return configs[providerId] ?? null
}
```

**Step 4: Run to confirm pass**

```bash
npx vitest run src/lib/oauth/__tests__/config.test.ts
```

**Step 5: Commit**

```bash
git add src/lib/oauth/config.ts src/lib/oauth/__tests__/config.test.ts
git commit -m "feat: add OAuth provider config"
```

---

## Task 3: Token Exchange (`src/lib/oauth/exchange.ts`)

Exchanges an authorization code for access/refresh tokens.

**Files:**
- Create: `src/lib/oauth/exchange.ts`
- Create: `src/lib/oauth/__tests__/exchange.test.ts`

**Step 1: Write failing tests**

```typescript
// src/lib/oauth/__tests__/exchange.test.ts
import { describe, it, expect, vi, beforeEach } from 'vitest'

global.fetch = vi.fn()

import { exchangeCodeForToken } from '../exchange'
import type { OAuthProviderConfig } from '../config'

const MOCK_CONFIG: OAuthProviderConfig = {
  clientId: 'client-id',
  clientSecret: 'secret',
  authorizationUrl: 'https://example.com/authorize',
  tokenUrl: 'https://example.com/token',
  scopes: ['read'],
  redirectUri: 'http://localhost:4567/api/oauth/callback/test',
  supportsRefresh: true,
}

describe('exchangeCodeForToken', () => {
  beforeEach(() => { vi.resetAllMocks() })

  it('returns tokens on success', async () => {
    vi.mocked(global.fetch).mockResolvedValue({
      ok: true,
      json: async () => ({
        access_token: 'act-123',
        refresh_token: 'rft-456',
        expires_in: 3600,
        token_type: 'bearer',
      }),
    } as Response)

    const tokens = await exchangeCodeForToken('code-abc', MOCK_CONFIG)
    expect(tokens.access_token).toBe('act-123')
    expect(tokens.refresh_token).toBe('rft-456')
    expect(tokens.expires_at).toBeGreaterThan(Date.now() / 1000)
  })

  it('sets expires_at to null when no expires_in', async () => {
    vi.mocked(global.fetch).mockResolvedValue({
      ok: true,
      json: async () => ({ access_token: 'act', token_type: 'bearer' }),
    } as Response)

    const tokens = await exchangeCodeForToken('code', MOCK_CONFIG)
    expect(tokens.expires_at).toBeNull()
    expect(tokens.refresh_token).toBeNull()
  })

  it('throws on HTTP error', async () => {
    vi.mocked(global.fetch).mockResolvedValue({ ok: false, status: 400 } as Response)
    await expect(exchangeCodeForToken('bad-code', MOCK_CONFIG)).rejects.toThrow('Token exchange failed')
  })

  it('throws on OAuth error in response body', async () => {
    vi.mocked(global.fetch).mockResolvedValue({
      ok: true,
      json: async () => ({ error: 'bad_verification_code' }),
    } as Response)
    await expect(exchangeCodeForToken('bad-code', MOCK_CONFIG)).rejects.toThrow('OAuth error')
  })
})
```

**Step 2: Run to confirm fail**

```bash
npx vitest run src/lib/oauth/__tests__/exchange.test.ts
```

**Step 3: Implement**

```typescript
// src/lib/oauth/exchange.ts
import type { OAuthProviderConfig } from './config'

export interface OAuthTokens {
  access_token: string
  refresh_token: string | null
  expires_at: number | null
  token_type: string
  scope?: string
}

export async function exchangeCodeForToken(
  code: string,
  config: OAuthProviderConfig
): Promise<OAuthTokens> {
  const params = new URLSearchParams({
    client_id: config.clientId,
    client_secret: config.clientSecret,
    code,
    redirect_uri: config.redirectUri,
    grant_type: 'authorization_code',
  })

  const res = await fetch(config.tokenUrl, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded',
      Accept: 'application/json',
    },
    body: params.toString(),
  })

  if (!res.ok) {
    throw new Error(`Token exchange failed: ${res.status}`)
  }

  const json = await res.json()

  if (json.error) {
    throw new Error(`OAuth error: ${json.error}`)
  }

  const expiresIn: number | null = json.expires_in ?? null
  const expires_at = expiresIn ? Math.floor(Date.now() / 1000) + expiresIn : null

  return {
    access_token: json.access_token,
    refresh_token: json.refresh_token ?? null,
    expires_at,
    token_type: json.token_type ?? 'bearer',
    scope: json.scope,
  }
}
```

**Step 4: Run to confirm pass**

```bash
npx vitest run src/lib/oauth/__tests__/exchange.test.ts
```

**Step 5: Commit**

```bash
git add src/lib/oauth/exchange.ts src/lib/oauth/__tests__/exchange.test.ts
git commit -m "feat: add OAuth code-to-token exchange"
```

---

## Task 4: Token Refresh (`src/lib/oauth/refresh.ts`)

Checks if an access token is close to expiry and refreshes it (used by Sentry, which has a 1-hour TTL).

**Files:**
- Create: `src/lib/oauth/refresh.ts`
- Create: `src/lib/oauth/__tests__/refresh.test.ts`

**Step 1: Write failing tests**

```typescript
// src/lib/oauth/__tests__/refresh.test.ts
import { describe, it, expect, vi, beforeEach } from 'vitest'

global.fetch = vi.fn()

import { needsRefresh, refreshAccessToken } from '../refresh'
import type { OAuthProviderConfig } from '../config'

const MOCK_CONFIG: OAuthProviderConfig = {
  clientId: 'id',
  clientSecret: 'secret',
  authorizationUrl: '',
  tokenUrl: 'https://sentry.io/oauth/token/',
  scopes: [],
  redirectUri: '',
  supportsRefresh: true,
}

describe('needsRefresh', () => {
  it('returns false when expires_at is null', () => {
    expect(needsRefresh(null)).toBe(false)
  })

  it('returns false when token expires far in the future', () => {
    const future = Math.floor(Date.now() / 1000) + 3600
    expect(needsRefresh(future)).toBe(false)
  })

  it('returns true when token expires within 10 minutes', () => {
    const soon = Math.floor(Date.now() / 1000) + 300
    expect(needsRefresh(soon)).toBe(true)
  })

  it('returns true when token is already expired', () => {
    const past = Math.floor(Date.now() / 1000) - 60
    expect(needsRefresh(past)).toBe(true)
  })
})

describe('refreshAccessToken', () => {
  beforeEach(() => { vi.resetAllMocks() })

  it('returns new tokens on success', async () => {
    vi.mocked(global.fetch).mockResolvedValue({
      ok: true,
      json: async () => ({
        access_token: 'new-act',
        refresh_token: 'new-rft',
        expires_in: 3600,
        token_type: 'bearer',
      }),
    } as Response)

    const tokens = await refreshAccessToken('old-refresh-token', MOCK_CONFIG)
    expect(tokens.access_token).toBe('new-act')
    expect(tokens.refresh_token).toBe('new-rft')
    expect(tokens.expires_at).toBeGreaterThan(Date.now() / 1000)
  })

  it('keeps old refresh_token when provider does not return a new one', async () => {
    vi.mocked(global.fetch).mockResolvedValue({
      ok: true,
      json: async () => ({ access_token: 'new-act', expires_in: 3600, token_type: 'bearer' }),
    } as Response)

    const tokens = await refreshAccessToken('original-rft', MOCK_CONFIG)
    expect(tokens.refresh_token).toBe('original-rft')
  })

  it('throws on HTTP error', async () => {
    vi.mocked(global.fetch).mockResolvedValue({ ok: false, status: 401 } as Response)
    await expect(refreshAccessToken('bad-token', MOCK_CONFIG)).rejects.toThrow('Token refresh failed')
  })
})
```

**Step 2: Run to confirm fail**

```bash
npx vitest run src/lib/oauth/__tests__/refresh.test.ts
```

**Step 3: Implement**

```typescript
// src/lib/oauth/refresh.ts
import type { OAuthProviderConfig } from './config'
import type { OAuthTokens } from './exchange'

const REFRESH_THRESHOLD_SECONDS = 600 // refresh if < 10 minutes remaining

export function needsRefresh(expiresAt: number | null): boolean {
  if (expiresAt === null) return false
  return expiresAt - Math.floor(Date.now() / 1000) < REFRESH_THRESHOLD_SECONDS
}

export async function refreshAccessToken(
  refreshToken: string,
  config: OAuthProviderConfig
): Promise<OAuthTokens> {
  const params = new URLSearchParams({
    client_id: config.clientId,
    client_secret: config.clientSecret,
    grant_type: 'refresh_token',
    refresh_token: refreshToken,
  })

  const res = await fetch(config.tokenUrl, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded',
      Accept: 'application/json',
    },
    body: params.toString(),
  })

  if (!res.ok) {
    throw new Error(`Token refresh failed: ${res.status}`)
  }

  const json = await res.json()

  if (json.error) {
    throw new Error(`Refresh error: ${json.error}`)
  }

  const expiresIn: number | null = json.expires_in ?? null
  const expires_at = expiresIn ? Math.floor(Date.now() / 1000) + expiresIn : null

  return {
    access_token: json.access_token,
    // Some providers don't return a new refresh_token — keep the old one
    refresh_token: json.refresh_token ?? refreshToken,
    expires_at,
    token_type: json.token_type ?? 'bearer',
  }
}
```

**Step 4: Run to confirm pass**

```bash
npx vitest run src/lib/oauth/__tests__/refresh.test.ts
```

**Step 5: Commit**

```bash
git add src/lib/oauth/refresh.ts src/lib/oauth/__tests__/refresh.test.ts
git commit -m "feat: add OAuth token refresh with expiry detection"
```

---

## Task 5: Authorize Route (`/api/oauth/authorize/[provider]`)

Generates state and redirects user to the provider's authorization page.

**Files:**
- Create: `src/app/api/oauth/authorize/[provider]/route.ts`
- Create: `src/app/api/oauth/authorize/[provider]/__tests__/route.test.ts`

**Step 1: Write failing tests**

```typescript
// src/app/api/oauth/authorize/[provider]/__tests__/route.test.ts
import { describe, it, expect, vi } from 'vitest'

vi.mock('@/lib/supabase/server', () => ({
  createClient: vi.fn().mockResolvedValue({
    auth: { getUser: vi.fn().mockResolvedValue({ data: { user: { id: 'user-1' } } }) },
  }),
}))

vi.mock('@/lib/oauth/state', () => ({
  generateState: vi.fn().mockReturnValue('test-state-123'),
  setStateCookie: vi.fn().mockResolvedValue(undefined),
  setLabelCookie: vi.fn().mockResolvedValue(undefined),
}))

vi.mock('@/lib/oauth/config', () => ({
  getOAuthConfig: vi.fn().mockReturnValue({
    clientId: 'gh-client-id',
    authorizationUrl: 'https://github.com/login/oauth/authorize',
    scopes: ['read:user'],
    redirectUri: 'http://localhost:4567/api/oauth/callback/github',
    supportsRefresh: false,
  }),
}))

import { GET } from '../route'

function makeRequest(provider: string, label?: string) {
  const url = `http://localhost:4567/api/oauth/authorize/${provider}${label ? `?label=${label}` : ''}`
  return new Request(url)
}

describe('GET /api/oauth/authorize/[provider]', () => {
  it('redirects to provider authorization URL', async () => {
    const res = await GET(makeRequest('github') as never, { params: Promise.resolve({ provider: 'github' }) })
    expect(res.status).toBe(307)
    expect(res.headers.get('location')).toContain('github.com/login/oauth/authorize')
  })

  it('includes state in redirect URL', async () => {
    const res = await GET(makeRequest('github') as never, { params: Promise.resolve({ provider: 'github' }) })
    expect(res.headers.get('location')).toContain('state=test-state-123')
  })

  it('returns 400 for unknown provider', async () => {
    const { getOAuthConfig } = await import('@/lib/oauth/config')
    vi.mocked(getOAuthConfig).mockReturnValueOnce(null)
    const res = await GET(makeRequest('unknown') as never, { params: Promise.resolve({ provider: 'unknown' }) })
    expect(res.status).toBe(400)
  })

  it('redirects unauthenticated users to /login', async () => {
    const { createClient } = await import('@/lib/supabase/server')
    vi.mocked(createClient).mockResolvedValueOnce({
      auth: { getUser: vi.fn().mockResolvedValue({ data: { user: null } }) },
    } as never)
    const res = await GET(makeRequest('github') as never, { params: Promise.resolve({ provider: 'github' }) })
    expect(res.status).toBe(307)
    expect(res.headers.get('location')).toContain('/login')
  })
})
```

**Step 2: Run to confirm fail**

```bash
npx vitest run "src/app/api/oauth/authorize/[provider]/__tests__/route.test.ts"
```

**Step 3: Implement**

```typescript
// src/app/api/oauth/authorize/[provider]/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { generateState, setStateCookie, setLabelCookie } from '@/lib/oauth/state'
import { getOAuthConfig } from '@/lib/oauth/config'

export async function GET(
  req: NextRequest,
  { params }: { params: Promise<{ provider: string }> }
) {
  const { provider } = await params

  const supabase = await createClient()
  const { data: { user } } = await supabase.auth.getUser()
  if (!user) {
    return NextResponse.redirect(new URL('/login', req.url))
  }

  const config = getOAuthConfig(provider)
  if (!config) {
    return NextResponse.json({ error: 'Unknown provider' }, { status: 400 })
  }

  const label = req.nextUrl.searchParams.get('label') ?? ''
  const state = generateState()

  await setStateCookie(state)
  if (label) await setLabelCookie(label)

  const authUrl = new URL(config.authorizationUrl)
  authUrl.searchParams.set('client_id', config.clientId)
  authUrl.searchParams.set('redirect_uri', config.redirectUri)
  authUrl.searchParams.set('state', state)
  if (config.scopes.length > 0) {
    authUrl.searchParams.set('scope', config.scopes.join(' '))
  }

  return NextResponse.redirect(authUrl.toString())
}
```

**Step 4: Run to confirm pass**

```bash
npx vitest run "src/app/api/oauth/authorize/[provider]/__tests__/route.test.ts"
```

**Step 5: Commit**

```bash
git add "src/app/api/oauth/authorize/[provider]/"
git commit -m "feat: add /api/oauth/authorize/[provider] route"
```

---

## Task 6: Callback Route (`/api/oauth/callback/[provider]`)

Receives the authorization code, exchanges it for tokens, saves the service record, and registers the QStash schedule.

**Special case — Sentry:** After exchanging the code, make one additional API call to `GET https://sentry.io/api/0/organizations/` to get the user's org slug. Store it alongside the tokens: `{ access_token, refresh_token, expires_at, orgSlug }`.

**Files:**
- Create: `src/app/api/oauth/callback/[provider]/route.ts`
- Create: `src/app/api/oauth/callback/[provider]/__tests__/route.test.ts`

**Step 1: Write failing tests**

```typescript
// src/app/api/oauth/callback/[provider]/__tests__/route.test.ts
import { describe, it, expect, vi, beforeEach } from 'vitest'

vi.mock('@/lib/supabase/server', () => ({
  createClient: vi.fn(),
}))
vi.mock('@/lib/oauth/state', () => ({
  verifyStateCookie: vi.fn().mockResolvedValue(true),
  getLabelCookie: vi.fn().mockResolvedValue('My GitHub'),
}))
vi.mock('@/lib/oauth/config', () => ({
  getOAuthConfig: vi.fn().mockReturnValue({
    clientId: 'id', clientSecret: 'secret',
    tokenUrl: 'https://github.com/login/oauth/access_token',
    redirectUri: 'http://localhost/api/oauth/callback/github',
    scopes: [], supportsRefresh: false,
  }),
}))
vi.mock('@/lib/oauth/exchange', () => ({
  exchangeCodeForToken: vi.fn().mockResolvedValue({
    access_token: 'act', refresh_token: null, expires_at: null, token_type: 'bearer',
  }),
}))
vi.mock('@/lib/crypto', () => ({
  encrypt: vi.fn().mockReturnValue('encrypted'),
}))
vi.mock('@/lib/providers', () => ({
  getProvider: vi.fn().mockReturnValue({ id: 'github', name: 'GitHub' }),
}))
vi.mock('@/lib/qstash', () => ({
  registerServiceSchedule: vi.fn().mockResolvedValue('qs-123'),
}))

import { createClient } from '@/lib/supabase/server'
import { GET } from '../route'

function makeCallbackRequest(provider: string, params: Record<string, string> = {}) {
  const url = new URL(`http://localhost/api/oauth/callback/${provider}`)
  Object.entries({ code: 'test-code', state: 'test-state', ...params }).forEach(
    ([k, v]) => url.searchParams.set(k, v)
  )
  return new Request(url.toString())
}

const MOCK_DB = {
  from: vi.fn().mockReturnValue({
    insert: vi.fn().mockReturnThis(),
    update: vi.fn().mockReturnThis(),
    select: vi.fn().mockReturnThis(),
    eq: vi.fn().mockReturnThis(),
    single: vi.fn().mockResolvedValue({ data: { id: 'svc-new' }, error: null }),
  }),
  auth: { getUser: vi.fn().mockResolvedValue({ data: { user: { id: 'user-1' } } }) },
}

describe('GET /api/oauth/callback/[provider]', () => {
  beforeEach(() => {
    vi.mocked(createClient).mockResolvedValue(MOCK_DB as never)
  })

  it('redirects to /dashboard on success', async () => {
    const res = await GET(makeCallbackRequest('github') as never, {
      params: Promise.resolve({ provider: 'github' })
    })
    expect(res.status).toBe(307)
    expect(res.headers.get('location')).toContain('/dashboard')
  })

  it('redirects to /connect on error=access_denied', async () => {
    const res = await GET(
      makeCallbackRequest('github', { error: 'access_denied', code: '', state: '' }) as never,
      { params: Promise.resolve({ provider: 'github' }) }
    )
    expect(res.status).toBe(307)
    expect(res.headers.get('location')).toContain('/connect')
  })

  it('redirects to /connect/[provider]?error=oauth_failed on invalid state', async () => {
    const { verifyStateCookie } = await import('@/lib/oauth/state')
    vi.mocked(verifyStateCookie).mockResolvedValueOnce(false)
    const res = await GET(makeCallbackRequest('github') as never, {
      params: Promise.resolve({ provider: 'github' })
    })
    expect(res.headers.get('location')).toContain('oauth_failed')
  })
})
```

**Step 2: Run to confirm fail**

```bash
npx vitest run "src/app/api/oauth/callback/[provider]/__tests__/route.test.ts"
```

**Step 3: Implement**

```typescript
// src/app/api/oauth/callback/[provider]/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { verifyStateCookie, getLabelCookie } from '@/lib/oauth/state'
import { getOAuthConfig } from '@/lib/oauth/config'
import { exchangeCodeForToken, type OAuthTokens } from '@/lib/oauth/exchange'
import { encrypt } from '@/lib/crypto'
import { getProvider } from '@/lib/providers'
import { registerServiceSchedule } from '@/lib/qstash'

async function getSentryOrgSlug(accessToken: string): Promise<string | null> {
  try {
    const res = await fetch('https://sentry.io/api/0/organizations/', {
      headers: { Authorization: `Bearer ${accessToken}` },
    })
    if (!res.ok) return null
    const orgs = await res.json()
    return orgs[0]?.slug ?? null
  } catch {
    return null
  }
}

export async function GET(
  req: NextRequest,
  { params }: { params: Promise<{ provider: string }> }
) {
  const { provider } = await params
  const url = req.nextUrl

  // Provider cancelled authorization
  if (url.searchParams.get('error')) {
    return NextResponse.redirect(new URL('/connect', req.url))
  }

  const code = url.searchParams.get('code')
  const state = url.searchParams.get('state')

  if (!code || !state) {
    return NextResponse.redirect(new URL('/connect', req.url))
  }

  // CSRF check
  const stateValid = await verifyStateCookie(state)
  if (!stateValid) {
    return NextResponse.redirect(new URL(`/connect/${provider}?error=oauth_failed`, req.url))
  }

  const supabase = await createClient()
  const { data: { user } } = await supabase.auth.getUser()
  if (!user) return NextResponse.redirect(new URL('/login', req.url))

  const config = getOAuthConfig(provider)
  const serviceProvider = getProvider(provider)
  if (!config || !serviceProvider) {
    return NextResponse.redirect(new URL('/connect', req.url))
  }

  try {
    const tokens = await exchangeCodeForToken(code, config)
    const label = await getLabelCookie() ?? serviceProvider.name

    // Sentry needs org slug for metric fetching — store it with tokens
    const credentialsPayload: OAuthTokens & { orgSlug?: string } = { ...tokens }
    if (provider === 'sentry') {
      const orgSlug = await getSentryOrgSlug(tokens.access_token)
      if (orgSlug) credentialsPayload.orgSlug = orgSlug
    }

    const encryptedCredentials = encrypt(
      JSON.stringify(credentialsPayload),
      process.env.ENCRYPTION_KEY!
    )

    const { data, error: dbError } = await supabase
      .from('connected_services')
      .insert({
        user_id: user.id,
        provider_id: provider,
        label,
        credentials: encryptedCredentials,
      })
      .select('id')
      .single()

    if (dbError) throw dbError

    // Register QStash schedule (non-fatal)
    try {
      const scheduleId = await registerServiceSchedule(data.id)
      await supabase
        .from('connected_services')
        .update({ qstash_schedule_id: scheduleId })
        .eq('id', data.id)
    } catch {
      console.error('[qstash] Failed to register schedule for OAuth service')
    }

    return NextResponse.redirect(new URL('/dashboard', req.url))
  } catch {
    return NextResponse.redirect(new URL(`/connect/${provider}?error=oauth_failed`, req.url))
  }
}
```

**Step 4: Run to confirm pass**

```bash
npx vitest run "src/app/api/oauth/callback/[provider]/__tests__/route.test.ts"
```

**Step 5: Commit**

```bash
git add "src/app/api/oauth/callback/[provider]/"
git commit -m "feat: add /api/oauth/callback/[provider] route"
```

---

## Task 7: Update `fetch.ts` — OAuth Token Support

GitHub and Vercel currently use `credentials.token`; Sentry uses `credentials.authToken` + `credentials.orgSlug`. After OAuth, the token lives in `credentials.access_token`. Update `fetch.ts` to fall back gracefully so both old (API key) and new (OAuth) connections work.

**Files:**
- Modify: `src/lib/providers/fetch.ts`

**Step 1: Update the three OAuth provider cases**

In `src/lib/providers/fetch.ts`, change the `github`, `vercel`, and `sentry` cases:

```typescript
case 'github': {
  // OAuth: access_token | Legacy PAT: token
  const token = credentials.access_token ?? credentials.token
  const r = await fetchGitHubMetrics(token)
  return [
    { collectorId: 'actions_minutes_used', value: r.minutesUsed ?? null, valueText: null, unit: 'minutes', status: r.status },
    { collectorId: 'actions_minutes_limit', value: r.minutesLimit ?? null, valueText: null, unit: 'minutes', status: 'healthy' },
  ]
}
case 'vercel': {
  // OAuth: access_token | Legacy API token: token
  const token = credentials.access_token ?? credentials.token
  const r = await fetchVercelMetrics(token)
  return [
    { collectorId: 'bandwidth_used', value: r.bandwidthUsed ?? null, valueText: null, unit: 'GB', status: r.status },
    { collectorId: 'deployment_status', value: null, valueText: r.deploymentStatus ?? null, unit: '', status: r.status },
  ]
}
case 'sentry': {
  // OAuth: access_token + orgSlug (stored in creds) | Legacy: authToken + orgSlug
  const token = credentials.access_token ?? credentials.authToken
  const orgSlug = credentials.orgSlug ?? ''
  const r = await fetchSentryMetrics(token, orgSlug)
  return [{ collectorId: 'error_count', value: r.value ?? null, valueText: null, unit: 'events', status: r.status }]
}
```

**Step 2: Run full test suite to confirm no regressions**

```bash
npx vitest run
```

Expected: All existing tests still pass.

**Step 3: Commit**

```bash
git add src/lib/providers/fetch.ts
git commit -m "feat: support OAuth access_token in fetch.ts for github/vercel/sentry"
```

---

## Task 8: Update Provider Definitions — `authType: 'oauth2'`

Change GitHub, Vercel, and Sentry provider definitions so `connect/[providerId]/page.tsx` shows the OAuth button UI.

**Files:**
- Modify: `src/lib/providers/github.ts` (line 8: `authType: 'token'` → `'oauth2'`)
- Modify: `src/lib/providers/vercel.ts` (line 9: `authType: 'token'` → `'oauth2'`)
- Modify: `src/lib/providers/sentry.ts` (line 8: `authType: 'api_key'` → `'oauth2'`)

For Sentry, also remove the `credentials` array (org slug is fetched automatically during OAuth callback, not entered by user):

```typescript
// sentry.ts: set credentials to empty array
credentials: [],
```

**Step 1: Make the changes**

In each file, change only the `authType` field (and `credentials: []` for Sentry).

**Step 2: Run tests**

```bash
npx vitest run
```

**Step 3: Commit**

```bash
git add src/lib/providers/github.ts src/lib/providers/vercel.ts src/lib/providers/sentry.ts
git commit -m "feat: set authType to oauth2 for github, vercel, sentry providers"
```

---

## Task 9: Connect Page — OAuth Button UI

Replace the "not yet implemented" stub in `src/app/(app)/connect/[providerId]/page.tsx` with the actual OAuth authorize button.

**Files:**
- Modify: `src/app/(app)/connect/[providerId]/page.tsx`

**Step 1: Read the current file**

The current stub is at lines 31–38:
```typescript
if (provider.authType === 'oauth2') {
  return (
    <div className="p-8 max-w-md">
      <p className="text-muted-foreground text-sm">OAuth flow not yet implemented (Phase 2)</p>
      <Button variant="outline" size="sm" className="mt-4" onClick={() => router.back()}>Go back</Button>
    </div>
  )
}
```

**Step 2: Replace the stub with the OAuth UI**

Replace those 9 lines with:

```typescript
if (provider.authType === 'oauth2') {
  function handleOAuthConnect() {
    const params = new URLSearchParams()
    if (label) params.set('label', label)
    window.location.href = `/api/oauth/authorize/${providerId}?${params.toString()}`
  }

  return (
    <div className="p-8">
      <Link
        href="/connect"
        className="inline-flex items-center gap-1 text-sm text-muted-foreground hover:text-foreground transition-colors mb-6"
      >
        <ChevronLeft className="h-4 w-4" />
        Back to services
      </Link>

      <div className="max-w-md">
        <div className="bg-card border border-border rounded-xl p-6">
          <div className="flex items-center gap-3 mb-6 pb-4 border-b border-border">
            <ProviderIcon providerId={providerId} size={40} />
            <div>
              <h1 className="text-base font-semibold text-foreground">Connect {provider.name}</h1>
              <p className="text-xs text-muted-foreground">Authorize via {provider.name}</p>
            </div>
          </div>

          <div className="space-y-4">
            <div className="space-y-1.5">
              <Label className="text-xs text-muted-foreground">Display name (optional)</Label>
              <Input
                placeholder={provider.name}
                value={label}
                onChange={(e) => setLabel(e.target.value)}
                className="bg-secondary border-border text-foreground placeholder:text-muted-foreground/50"
              />
            </div>

            <Button
              className="w-full bg-primary hover:bg-primary/90 text-primary-foreground"
              onClick={handleOAuthConnect}
            >
              Authorize with {provider.name} →
            </Button>

            <p className="text-xs text-muted-foreground text-center">
              You&apos;ll be redirected to {provider.name} to grant read-only access.
            </p>
          </div>
        </div>
      </div>
    </div>
  )
}
```

Also add the error display for `?error=oauth_failed` in the URL. After the `use(params)` line, add:

```typescript
const searchParams = useSearchParams()
const oauthError = searchParams.get('error')
```

And add inside the OAuth UI above the button, after the label input:

```typescript
{oauthError === 'oauth_failed' && (
  <p className="text-xs text-red-400 bg-red-500/10 border border-red-500/20 rounded-md px-3 py-2">
    Authorization failed — please try again.
  </p>
)}
```

Note: `useSearchParams()` requires `<Suspense>` wrapping in the parent. Since this is already a client component, wrap the export in Suspense or move `useSearchParams` inside a child component. Simplest fix: add `import { Suspense } from 'react'` and wrap the default export.

**Step 3: Run build check**

```bash
npx tsc --noEmit
```

Fix any TypeScript errors before committing.

**Step 4: Commit**

```bash
git add "src/app/(app)/connect/[providerId]/page.tsx"
git commit -m "feat: add OAuth authorize button to connect page"
```

---

## Task 10: Poll Service — Proactive Token Refresh

Before fetching metrics for OAuth providers, check if the access token is close to expiry and refresh it if needed.

**Files:**
- Modify: `src/app/api/cron/poll-service/route.ts`

**Step 1: Read the current file to find the right insertion point**

The credentials are decrypted near the top of the `handler` function:
```typescript
const credentials = JSON.parse(decrypt(service.credentials, process.env.ENCRYPTION_KEY!))
```

**Step 2: Add token refresh logic after decryption**

After the credentials line, add:

```typescript
import { getOAuthConfig } from '@/lib/oauth/config'
import { needsRefresh, refreshAccessToken } from '@/lib/oauth/refresh'
import { encrypt } from '@/lib/crypto'

// ... after credentials = JSON.parse(decrypt(...))

if (provider.authType === 'oauth2') {
  const oauthConfig = getOAuthConfig(service.provider_id)
  if (oauthConfig?.supportsRefresh && needsRefresh(credentials.expires_at) && credentials.refresh_token) {
    try {
      const newTokens = await refreshAccessToken(credentials.refresh_token, oauthConfig)
      const updated = { ...credentials, ...newTokens }
      const encryptedUpdated = encrypt(JSON.stringify(updated), process.env.ENCRYPTION_KEY!)
      await supabase.from('connected_services')
        .update({ credentials: encryptedUpdated })
        .eq('id', serviceId)
      Object.assign(credentials, updated)
    } catch {
      // Refresh failed — proceed with existing token, will mark auth_expired if 401
      console.error('[poll-service] Token refresh failed for', serviceId)
    }
  }
}
```

**Step 3: Run full tests**

```bash
npx vitest run
```

**Step 4: Commit**

```bash
git add src/app/api/cron/poll-service/route.ts
git commit -m "feat: proactive OAuth token refresh in poll-service"
```

---

## Task 11: Re-Auth Banner — OAuth Re-Authorize Button

When a service using OAuth has `auth_expired`, the existing credential banner shows password input fields. For OAuth providers, show a "Re-authorize" button instead.

**Files:**
- Modify: `src/components/credential-reauth-banner.tsx`

**Step 1: Add `authType` prop**

Add `authType?: string` to `CredentialReauthBannerProps`. When `authType === 'oauth2'`, render the re-authorize flow instead of the credential form.

**Step 2: Implement**

```typescript
// Add to props interface:
authType?: string

// Replace the banner body with a conditional:
export function CredentialReauthBanner({
  serviceId,
  providerId,
  credentialFields,
  authType,
  onSuccess,
}: CredentialReauthBannerProps) {
  // ... existing state ...

  // OAuth re-authorize: just redirect to the OAuth flow
  if (authType === 'oauth2') {
    return (
      <div className="bg-red-950/30 border border-red-800 rounded-lg p-4 mb-6">
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-2 text-red-400">
            <AlertTriangle className="h-4 w-4" />
            <span className="text-sm font-medium">Authorization expired. Re-authorize to resume monitoring.</span>
          </div>
          <Button
            size="sm"
            variant="outline"
            className="border-red-800 text-red-400 hover:bg-red-950"
            onClick={() => { window.location.href = `/api/oauth/authorize/${providerId}` }}
          >
            Re-authorize
          </Button>
        </div>
      </div>
    )
  }

  // Existing API key banner below (unchanged)
  return ( /* ... existing JSX ... */ )
}
```

**Step 3: Pass `authType` from the service detail page**

In `src/app/(app)/dashboard/[serviceId]/page.tsx`, pass the provider's `authType` to the banner:

```typescript
{service.auth_expired && provider && (
  <CredentialReauthBanner
    serviceId={serviceId}
    providerId={service.provider_id}
    credentialFields={provider.credentials ?? []}
    authType={provider.authType}
  />
)}
```

**Step 4: Run tests and TypeScript check**

```bash
npx vitest run
npx tsc --noEmit
```

**Step 5: Commit**

```bash
git add src/components/credential-reauth-banner.tsx "src/app/(app)/dashboard/[serviceId]/page.tsx"
git commit -m "feat: re-authorize button in reauth banner for OAuth providers"
```

---

## Task 12: Final Verification

**Step 1: Run full test suite**

```bash
npx vitest run
```

Expected: All tests pass (95+ from Phase 2 + ~20 new OAuth tests).

**Step 2: TypeScript check**

```bash
npx tsc --noEmit
```

Expected: Zero errors.

**Step 3: Build check**

```bash
pnpm build
```

Expected: Successful build. Confirm these routes appear:
- `/api/oauth/authorize/[provider]`
- `/api/oauth/callback/[provider]`

**Step 4: Add env vars to `.env.local`**

```bash
GITHUB_CLIENT_ID=...
GITHUB_CLIENT_SECRET=...
VERCEL_CLIENT_ID=...
VERCEL_CLIENT_SECRET=...
SENTRY_CLIENT_ID=...
SENTRY_CLIENT_SECRET=...
```

**Step 5: Final commit**

```bash
git add -A
git commit -m "test: oauth2 integration verified, all tests and build passing"
```

---

## Environment Variables Required

```bash
# New in Phase 3 (OAuth)
GITHUB_CLIENT_ID=...        # GitHub OAuth App → Settings → Developer settings
GITHUB_CLIENT_SECRET=...
VERCEL_CLIENT_ID=...        # Vercel → Settings → Integrations → OAuth
VERCEL_CLIENT_SECRET=...
SENTRY_CLIENT_ID=...        # Sentry → Settings → Developer Settings → New Internal Integration
SENTRY_CLIENT_SECRET=...
```

## Dependency Order

```
Task 1 (state.ts) ─┐
Task 2 (config.ts) ─┼──→ Task 5 (authorize route)
Task 3 (exchange.ts)─┤──→ Task 6 (callback route)
Task 4 (refresh.ts) ─┘──→ Task 10 (poll-service)
Task 7 (fetch.ts) — independent
Task 8 (provider authType) → Task 9 (connect page UI)
Task 11 (reauth banner) — independent
Task 12 (verification) — after all
```

---

*Plan written by: Claude, 2026-02-18*
