# StackPulse Phase 2 — Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Transform StackPulse into a real-time production monitoring platform — continuous background polling via Upstash QStash, email alerts via Resend, 6 new providers, and a complete product UI.

**Architecture:** QStash schedules one independent cron per service (*/5 min) → calls `/api/cron/poll-service` → collects metrics → checks alert rules → sends Resend email if threshold crossed. Supabase Realtime pushes new snapshots to the UI instantly.

**Tech Stack:** Next.js 16 App Router, TypeScript strict, Supabase, Resend, Upstash QStash, Recharts, Vitest + @testing-library/react.

---

## Task 1: Install @upstash/qstash + DB Migration

**Files:**
- Modify: `package.json` (via pnpm)
- Create: `supabase/migrations/20260218000001_phase2_columns.sql`

**Step 1: Install SDK**

```bash
pnpm add @upstash/qstash
```

**Step 2: Create migration file**

```sql
-- supabase/migrations/20260218000001_phase2_columns.sql

-- Track QStash schedule ID per service
ALTER TABLE public.connected_services
  ADD COLUMN IF NOT EXISTS qstash_schedule_id text;

-- Notification cooldown: prevent email spam (1h per rule)
ALTER TABLE public.alert_configs
  ADD COLUMN IF NOT EXISTS last_notified_at timestamptz;

-- Auto-cleanup snapshots older than 7 days (run via pg_cron or manually)
-- NOTE: Enable pg_cron in Supabase dashboard → Extensions first
-- SELECT cron.schedule('cleanup-old-snapshots', '0 3 * * *',
--   'DELETE FROM public.metric_snapshots WHERE fetched_at < NOW() - INTERVAL ''7 days''');
```

**Step 3: Apply migration locally**

```bash
npx supabase db reset
```

Expected: Migration applies cleanly, existing data preserved.

**Step 4: Verify columns exist**

```bash
npx supabase db diff
```

Expected: Shows new columns `qstash_schedule_id` and `last_notified_at`.

**Step 5: Add environment variables to `.env.local`**

```bash
QSTASH_TOKEN=...
QSTASH_CURRENT_SIGNING_KEY=...
QSTASH_NEXT_SIGNING_KEY=...
```

**Step 6: Commit**

```bash
git add pnpm-lock.yaml package.json supabase/migrations/20260218000001_phase2_columns.sql
git commit -m "chore: add @upstash/qstash and phase2 DB migration"
```

---

## Task 2: Alert Engine — Threshold Detection

**Files:**
- Modify: `src/lib/alerts/engine.ts`
- Modify: `src/lib/alerts/engine.test.ts`

The engine already has `checkThreshold()`. Extend it to evaluate a full list of alert_configs against a new snapshot and return which rules fired.

**Step 1: Write the failing tests**

Add to `src/lib/alerts/engine.test.ts`:

```typescript
import { evaluateAlerts } from '@/lib/alerts/engine'

const baseRule = {
  id: 'rule-1',
  collector_id: 'credit_balance',
  condition: 'lt' as const,
  threshold_numeric: 5,
  threshold_text: null,
  enabled: true,
  last_notified_at: null,
}

describe('evaluateAlerts', () => {
  it('returns triggered rules when threshold crossed', () => {
    const triggered = evaluateAlerts(
      [baseRule],
      { collectorId: 'credit_balance', value: 3.5, status: 'healthy' }
    )
    expect(triggered).toHaveLength(1)
    expect(triggered[0].id).toBe('rule-1')
  })

  it('returns empty when threshold not crossed', () => {
    const triggered = evaluateAlerts(
      [baseRule],
      { collectorId: 'credit_balance', value: 8, status: 'healthy' }
    )
    expect(triggered).toHaveLength(0)
  })

  it('skips disabled rules', () => {
    const triggered = evaluateAlerts(
      [{ ...baseRule, enabled: false }],
      { collectorId: 'credit_balance', value: 3.5, status: 'healthy' }
    )
    expect(triggered).toHaveLength(0)
  })

  it('skips rules for different collector', () => {
    const triggered = evaluateAlerts(
      [{ ...baseRule, collector_id: 'other_metric' }],
      { collectorId: 'credit_balance', value: 3.5, status: 'healthy' }
    )
    expect(triggered).toHaveLength(0)
  })

  it('respects 1-hour cooldown', () => {
    const recentlyNotified = {
      ...baseRule,
      last_notified_at: new Date(Date.now() - 30 * 60 * 1000).toISOString(), // 30 min ago
    }
    const triggered = evaluateAlerts(
      [recentlyNotified],
      { collectorId: 'credit_balance', value: 3.5, status: 'healthy' }
    )
    expect(triggered).toHaveLength(0)
  })

  it('fires again after cooldown expires', () => {
    const oldNotification = {
      ...baseRule,
      last_notified_at: new Date(Date.now() - 90 * 60 * 1000).toISOString(), // 90 min ago
    }
    const triggered = evaluateAlerts(
      [oldNotification],
      { collectorId: 'credit_balance', value: 3.5, status: 'healthy' }
    )
    expect(triggered).toHaveLength(1)
  })
})
```

**Step 2: Run to confirm fail**

```bash
npx vitest run src/lib/alerts/engine.test.ts
```

Expected: FAIL — `evaluateAlerts` not exported.

**Step 3: Implement evaluateAlerts**

Add to `src/lib/alerts/engine.ts`:

```typescript
interface AlertConfigRow {
  id: string
  collector_id: string
  condition: string
  threshold_numeric: number | null
  threshold_text: string | null
  enabled: boolean
  last_notified_at: string | null
}

interface SnapshotInput {
  collectorId: string
  value: number | string | null
  status: string
}

const COOLDOWN_MS = 60 * 60 * 1000 // 1 hour

export function evaluateAlerts(
  rules: AlertConfigRow[],
  snapshot: SnapshotInput
): AlertConfigRow[] {
  return rules.filter((rule) => {
    if (!rule.enabled) return false
    if (rule.collector_id !== snapshot.collectorId) return false
    if (snapshot.value === null) return false

    // Cooldown check
    if (rule.last_notified_at) {
      const elapsed = Date.now() - new Date(rule.last_notified_at).getTime()
      if (elapsed < COOLDOWN_MS) return false
    }

    const threshold = rule.threshold_numeric ?? rule.threshold_text ?? ''
    return checkThreshold(rule.condition as AlertCondition, threshold, snapshot.value)
  })
}
```

**Step 4: Run to confirm pass**

```bash
npx vitest run src/lib/alerts/engine.test.ts
```

Expected: All tests PASS.

**Step 5: Commit**

```bash
git add src/lib/alerts/engine.ts src/lib/alerts/engine.test.ts
git commit -m "feat: add evaluateAlerts with cooldown support"
```

---

## Task 3: `/api/cron/poll-service` — Core Worker

**Files:**
- Create: `src/app/api/cron/poll-service/route.ts`
- Create: `src/app/api/cron/poll-service/__tests__/route.test.ts`

This is the heart of Phase 2. QStash calls this endpoint every 5 minutes per service.

**Step 1: Write the failing tests**

```typescript
// src/app/api/cron/poll-service/__tests__/route.test.ts
import { describe, it, expect, vi, beforeEach } from 'vitest'

vi.mock('@upstash/qstash/nextjs', () => ({
  verifySignatureAppRouter: (fn: Function) => fn, // bypass signature in tests
}))

vi.mock('@/lib/supabase/server', () => ({
  createClient: vi.fn(),
}))

vi.mock('@/lib/crypto', () => ({
  decrypt: vi.fn().mockReturnValue(JSON.stringify({ apiKey: 'test-key' })),
}))

vi.mock('@/lib/providers', () => ({
  getProvider: vi.fn(),
}))

import { createClient } from '@/lib/supabase/server'
import { getProvider } from '@/lib/providers'
import { POST } from '../route'

const MOCK_SERVICE = {
  id: 'svc-1',
  provider_id: 'openrouter',
  credentials: 'encrypted',
  user_id: 'user-1',
  consecutive_failures: 0,
  enabled: true,
  qstash_schedule_id: 'qs-1',
}

const MOCK_PROVIDER = {
  id: 'openrouter',
  collectors: [{ id: 'credit_balance', metricType: 'currency', unit: 'USD' }],
}

function makeRequest(body: unknown) {
  return new Request('http://localhost/api/cron/poll-service', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(body),
  })
}

describe('POST /api/cron/poll-service', () => {
  it('returns 400 if serviceId missing', async () => {
    const res = await POST(makeRequest({}) as never)
    expect(res.status).toBe(400)
  })

  it('returns 404 if service not found', async () => {
    const mock = {
      from: vi.fn().mockReturnValue({
        select: vi.fn().mockReturnThis(),
        eq: vi.fn().mockReturnThis(),
        single: vi.fn().mockResolvedValue({ data: null, error: null }),
      }),
    }
    vi.mocked(createClient).mockResolvedValue(mock as never)
    const res = await POST(makeRequest({ serviceId: 'svc-1' }) as never)
    expect(res.status).toBe(404)
  })

  it('returns 200 on successful poll', async () => {
    vi.mocked(getProvider).mockReturnValue(MOCK_PROVIDER as never)
    const mock = {
      from: vi.fn().mockReturnValue({
        select: vi.fn().mockReturnThis(),
        eq: vi.fn().mockReturnThis(),
        single: vi.fn().mockResolvedValue({ data: MOCK_SERVICE, error: null }),
        insert: vi.fn().mockResolvedValue({ error: null }),
        update: vi.fn().mockReturnThis(),
        order: vi.fn().mockResolvedValue({ data: [], error: null }),
      }),
      auth: { getUser: vi.fn() },
    }
    vi.mocked(createClient).mockResolvedValue(mock as never)
    const res = await POST(makeRequest({ serviceId: 'svc-1' }) as never)
    expect(res.status).toBe(200)
  })
})
```

**Step 2: Run to confirm fail**

```bash
npx vitest run src/app/api/cron/poll-service/__tests__/route.test.ts
```

Expected: FAIL — module not found.

**Step 3: Implement the route**

```typescript
// src/app/api/cron/poll-service/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { verifySignatureAppRouter } from '@upstash/qstash/nextjs'
import { createClient } from '@/lib/supabase/server'
import { decrypt } from '@/lib/crypto'
import { getProvider } from '@/lib/providers'
import { evaluateAlerts } from '@/lib/alerts/engine'
import { sendAlertEmail } from '@/lib/notifications/email'
import { fetchProviderMetrics } from '@/lib/providers/fetch'

async function handler(req: NextRequest) {
  const body = await req.json()
  const { serviceId } = body

  if (!serviceId) {
    return NextResponse.json({ error: 'serviceId required' }, { status: 400 })
  }

  const supabase = await createClient()

  // Fetch the service
  const { data: service } = await supabase
    .from('connected_services')
    .select('id, provider_id, credentials, user_id, consecutive_failures, enabled, qstash_schedule_id')
    .eq('id', serviceId)
    .single()

  if (!service) {
    return NextResponse.json({ error: 'Service not found' }, { status: 404 })
  }

  if (!service.enabled) {
    return NextResponse.json({ skipped: true, reason: 'disabled' })
  }

  const provider = getProvider(service.provider_id)
  if (!provider) {
    return NextResponse.json({ error: 'Unknown provider' }, { status: 400 })
  }

  // Decrypt credentials
  const credentials = JSON.parse(decrypt(service.credentials, process.env.ENCRYPTION_KEY!))

  // Fetch metrics for each collector
  try {
    const snapshots = await fetchProviderMetrics(service.provider_id, credentials)

    if (snapshots.length > 0) {
      await supabase.from('metric_snapshots').insert(
        snapshots.map((s) => ({
          connected_service_id: serviceId,
          collector_id: s.collectorId,
          value: s.value,
          value_text: s.valueText,
          unit: s.unit,
          status: s.status,
        }))
      )
    }

    // Reset failure counter on success
    await supabase
      .from('connected_services')
      .update({ consecutive_failures: 0, auth_expired: false })
      .eq('id', serviceId)

    // Check alert rules for each snapshot
    const { data: rules } = await supabase
      .from('alert_configs')
      .select('id, collector_id, condition, threshold_numeric, threshold_text, enabled, last_notified_at')
      .eq('connected_service_id', serviceId)
      .eq('enabled', true)
      .order('created_at', { ascending: true })

    if (rules && rules.length > 0) {
      // Fetch user email for notifications
      const { data: userData } = await supabase.auth.admin.getUserById(service.user_id)
      const userEmail = userData?.user?.email

      for (const snapshot of snapshots) {
        const triggered = evaluateAlerts(rules, {
          collectorId: snapshot.collectorId,
          value: snapshot.value,
          status: snapshot.status,
        })

        for (const rule of triggered) {
          // Log alert event
          await supabase.from('alert_events').insert({
            alert_config_id: rule.id,
            triggered_value_numeric: typeof snapshot.value === 'number' ? snapshot.value : null,
            triggered_value_text: typeof snapshot.value === 'string' ? snapshot.value : null,
          })

          // Update cooldown timestamp
          await supabase
            .from('alert_configs')
            .update({ last_notified_at: new Date().toISOString() })
            .eq('id', rule.id)

          // Send email notification
          if (userEmail) {
            const collectorName = provider.collectors.find((c) => c.id === rule.collector_id)?.name ?? rule.collector_id
            await sendAlertEmail({
              to: userEmail,
              serviceName: service.provider_id,
              collectorName,
              condition: rule.condition,
              threshold: rule.threshold_numeric ?? rule.threshold_text ?? '',
              triggeredValue: snapshot.value ?? '',
              serviceId,
            })
          }
        }
      }
    }

    return NextResponse.json({ ok: true, snapshots: snapshots.length })
  } catch (err) {
    // Increment failure counter
    const newFailures = (service.consecutive_failures ?? 0) + 1
    const updates: Record<string, unknown> = { consecutive_failures: newFailures }

    if (newFailures >= 5) {
      updates.auth_expired = true
      updates.enabled = false
    }

    await supabase.from('connected_services').update(updates).eq('id', serviceId)

    return NextResponse.json({ error: String(err) }, { status: 500 })
  }
}

export const POST = verifySignatureAppRouter(handler)
```

**Step 4: Create `src/lib/providers/fetch.ts`** — unified dispatch to all provider fetchers:

```typescript
// src/lib/providers/fetch.ts
import { fetchOpenRouterMetrics } from './openrouter'
import { fetchResendMetrics } from './resend'
import { fetchSentryMetrics } from './sentry'

export interface SnapshotResult {
  collectorId: string
  value: number | null
  valueText: string | null
  unit: string
  status: string
}

export async function fetchProviderMetrics(
  providerId: string,
  credentials: Record<string, string>
): Promise<SnapshotResult[]> {
  switch (providerId) {
    case 'openrouter': {
      const r = await fetchOpenRouterMetrics(credentials.apiKey)
      return [{ collectorId: 'credit_balance', value: r.value ?? null, valueText: null, unit: 'USD', status: r.status }]
    }
    case 'resend': {
      const r = await fetchResendMetrics(credentials.apiKey)
      return [{ collectorId: 'connection_status', value: null, valueText: r.value ?? null, unit: '', status: r.status }]
    }
    case 'sentry': {
      const r = await fetchSentryMetrics(credentials.authToken, credentials.orgSlug)
      return [{ collectorId: 'error_count', value: r.value ?? null, valueText: null, unit: 'events', status: r.status }]
    }
    default:
      return []
  }
}
```

Note: As new providers are added (Tasks 7–12), add cases to this switch.

**Step 5: Run tests to confirm pass**

```bash
npx vitest run src/app/api/cron/poll-service/__tests__/route.test.ts
```

Expected: All tests PASS.

**Step 6: Commit**

```bash
git add src/app/api/cron/ src/lib/providers/fetch.ts
git commit -m "feat: add /api/cron/poll-service worker endpoint"
```

---

## Task 4: Email Notification Helper

**Files:**
- Create: `src/lib/notifications/email.ts`
- Create: `src/lib/notifications/__tests__/email.test.ts`

**Step 1: Write the failing test**

```typescript
// src/lib/notifications/__tests__/email.test.ts
import { describe, it, expect, vi } from 'vitest'

vi.mock('resend', () => ({
  Resend: vi.fn().mockImplementation(() => ({
    emails: { send: vi.fn().mockResolvedValue({ id: 'email-1' }) },
  })),
}))

import { sendAlertEmail } from '../email'

describe('sendAlertEmail', () => {
  it('calls Resend with correct recipient and subject', async () => {
    const { Resend } = await import('resend')
    const mockInstance = new (Resend as any)()

    await sendAlertEmail({
      to: 'user@example.com',
      serviceName: 'OpenRouter',
      collectorName: 'Credit Balance',
      condition: 'lt',
      threshold: 5,
      triggeredValue: 3.47,
      serviceId: 'svc-1',
    })

    expect(mockInstance.emails.send).toHaveBeenCalledWith(
      expect.objectContaining({
        to: 'user@example.com',
        subject: expect.stringContaining('OpenRouter'),
      })
    )
  })

  it('does not throw if Resend fails', async () => {
    const { Resend } = await import('resend')
    const mockInstance = new (Resend as any)()
    mockInstance.emails.send.mockRejectedValue(new Error('network'))

    await expect(
      sendAlertEmail({
        to: 'user@example.com',
        serviceName: 'OpenRouter',
        collectorName: 'Credit Balance',
        condition: 'lt',
        threshold: 5,
        triggeredValue: 3.47,
        serviceId: 'svc-1',
      })
    ).resolves.not.toThrow()
  })
})
```

**Step 2: Run to confirm fail**

```bash
npx vitest run src/lib/notifications/__tests__/email.test.ts
```

**Step 3: Implement**

```typescript
// src/lib/notifications/email.ts
import { Resend } from 'resend'

const resend = new Resend(process.env.RESEND_API_KEY)

const CONDITION_LABELS: Record<string, string> = {
  lt: 'dropped below',
  gt: 'exceeded',
  eq: 'equals',
  status_is: 'status changed to',
}

interface AlertEmailParams {
  to: string
  serviceName: string
  collectorName: string
  condition: string
  threshold: number | string
  triggeredValue: number | string
  serviceId: string
}

function formatValue(v: number | string, condition: string): string {
  if (typeof v === 'number') {
    // Heuristic: small numbers with decimals are currency
    if (v < 10000 && condition === 'lt') return `$${v.toFixed(2)}`
    return String(v)
  }
  return String(v)
}

export async function sendAlertEmail(params: AlertEmailParams): Promise<void> {
  const { to, serviceName, collectorName, condition, threshold, triggeredValue, serviceId } = params
  const conditionLabel = CONDITION_LABELS[condition] ?? condition
  const thresholdStr = typeof threshold === 'number' && condition === 'lt' ? `$${threshold}` : String(threshold)
  const valueStr = formatValue(triggeredValue as number, condition)
  const appUrl = process.env.NEXT_PUBLIC_APP_URL ?? 'http://localhost:4567'

  try {
    await resend.emails.send({
      from: 'StackPulse Alerts <alerts@stackpulse.app>',
      to,
      subject: `[StackPulse] Alert: ${collectorName} on ${serviceName}`,
      html: `
        <div style="font-family: monospace; max-width: 520px; margin: 0 auto; padding: 32px; background: #09090b; color: #fafafa;">
          <h2 style="color: #f59e0b; margin: 0 0 24px;">⚠ Alert Triggered</h2>
          <table style="width: 100%; border-collapse: collapse;">
            <tr><td style="padding: 6px 0; color: #71717a;">Service</td><td>${serviceName}</td></tr>
            <tr><td style="padding: 6px 0; color: #71717a;">Metric</td><td>${collectorName}</td></tr>
            <tr><td style="padding: 6px 0; color: #71717a;">Condition</td><td>${conditionLabel} ${thresholdStr}</td></tr>
            <tr><td style="padding: 6px 0; color: #71717a;">Current value</td><td style="color: #ef4444; font-weight: bold;">${valueStr}</td></tr>
            <tr><td style="padding: 6px 0; color: #71717a;">Triggered at</td><td>${new Date().toUTCString()}</td></tr>
          </table>
          <div style="margin-top: 32px;">
            <a href="${appUrl}/dashboard/${serviceId}"
               style="background: #10b981; color: #fff; padding: 10px 20px; text-decoration: none; border-radius: 6px;">
              View service →
            </a>
          </div>
        </div>
      `,
    })
  } catch {
    // Non-fatal — log but don't throw
    console.error('[sendAlertEmail] Failed to send alert email')
  }
}
```

**Step 4: Run tests**

```bash
npx vitest run src/lib/notifications/__tests__/email.test.ts
```

Expected: All PASS.

**Step 5: Commit**

```bash
git add src/lib/notifications/
git commit -m "feat: add Resend alert email notification helper"
```

---

## Task 5: QStash Schedule Registration

**Files:**
- Create: `src/lib/qstash.ts`
- Modify: `src/app/api/services/route.ts` (POST — register schedule after insert)
- Modify: `src/app/api/services/[id]/route.ts` (DELETE — cancel schedule)
- Create: `src/lib/__tests__/qstash.test.ts`

**Step 1: Write the failing test**

```typescript
// src/lib/__tests__/qstash.test.ts
import { describe, it, expect, vi } from 'vitest'

vi.mock('@upstash/qstash', () => ({
  Client: vi.fn().mockImplementation(() => ({
    schedules: {
      create: vi.fn().mockResolvedValue({ scheduleId: 'qs-abc' }),
      delete: vi.fn().mockResolvedValue({}),
    },
  })),
}))

import { registerServiceSchedule, unregisterServiceSchedule } from '../qstash'

describe('registerServiceSchedule', () => {
  it('returns a scheduleId', async () => {
    const id = await registerServiceSchedule('svc-1')
    expect(id).toBe('qs-abc')
  })
})

describe('unregisterServiceSchedule', () => {
  it('calls delete without throwing', async () => {
    await expect(unregisterServiceSchedule('qs-abc')).resolves.not.toThrow()
  })

  it('is a no-op when scheduleId is null', async () => {
    await expect(unregisterServiceSchedule(null)).resolves.not.toThrow()
  })
})
```

**Step 2: Run to confirm fail**

```bash
npx vitest run src/lib/__tests__/qstash.test.ts
```

**Step 3: Implement qstash.ts**

```typescript
// src/lib/qstash.ts
import { Client } from '@upstash/qstash'

const qstash = new Client({ token: process.env.QSTASH_TOKEN! })

const APP_URL = process.env.NEXT_PUBLIC_APP_URL ?? 'http://localhost:4567'

export async function registerServiceSchedule(serviceId: string): Promise<string> {
  const result = await qstash.schedules.create({
    destination: `${APP_URL}/api/cron/poll-service`,
    cron: '*/5 * * * *',
    body: JSON.stringify({ serviceId }),
    headers: { 'Content-Type': 'application/json' },
  })
  return result.scheduleId
}

export async function unregisterServiceSchedule(scheduleId: string | null): Promise<void> {
  if (!scheduleId) return
  try {
    await qstash.schedules.delete(scheduleId)
  } catch {
    // Best-effort cleanup — don't fail if already removed
    console.error('[qstash] Failed to delete schedule', scheduleId)
  }
}
```

**Step 4: Wire into `POST /api/services`**

After the service is inserted and initial metrics collected, add:

```typescript
// Inside POST /api/services — after snapshot collection
import { registerServiceSchedule } from '@/lib/qstash'

try {
  const scheduleId = await registerServiceSchedule(data.id)
  await supabase
    .from('connected_services')
    .update({ qstash_schedule_id: scheduleId })
    .eq('id', data.id)
} catch {
  // Schedule registration failure is non-fatal
  console.error('[qstash] Failed to register schedule for', data.id)
}
```

**Step 5: Wire into `DELETE /api/services/[id]`**

Before deleting the service, fetch and cancel its schedule:

```typescript
import { unregisterServiceSchedule } from '@/lib/qstash'

// Inside DELETE /api/services/[id] — before .delete()
const { data: svc } = await supabase
  .from('connected_services')
  .select('qstash_schedule_id')
  .eq('id', id)
  .eq('user_id', user.id)
  .single()

await unregisterServiceSchedule(svc?.qstash_schedule_id ?? null)
```

**Step 6: Run tests**

```bash
npx vitest run src/lib/__tests__/qstash.test.ts
npx vitest run
```

Expected: All PASS.

**Step 7: Commit**

```bash
git add src/lib/qstash.ts src/lib/__tests__/qstash.test.ts src/app/api/services/
git commit -m "feat: register/unregister QStash schedules on service connect/delete"
```

---

## Task 6: Credential Re-auth Route + UI

**Files:**
- Create: `src/app/api/services/[id]/credentials/route.ts`
- Create: `src/components/credential-reauth-banner.tsx`
- Modify: `src/components/service-card.tsx`
- Modify: `src/app/(app)/dashboard/[serviceId]/page.tsx`

**Step 1: Create PATCH `/api/services/[id]/credentials`**

```typescript
// src/app/api/services/[id]/credentials/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { encrypt } from '@/lib/crypto'
import { getProvider } from '@/lib/providers'
import { registerServiceSchedule } from '@/lib/qstash'

export async function PATCH(
  req: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const { id } = await params
  const supabase = await createClient()
  const { data: { user }, error: authError } = await supabase.auth.getUser()
  if (authError || !user) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })

  const body = await req.json()
  const { credentials, providerId } = body

  if (!credentials || !providerId) {
    return NextResponse.json({ error: 'credentials and providerId required' }, { status: 400 })
  }

  // Validate new credentials before saving
  const { validateCredentials } = await import('@/lib/providers/validator')
  const provider = getProvider(providerId)
  if (!provider) return NextResponse.json({ error: 'Unknown provider' }, { status: 400 })

  const encryptionKey = process.env.ENCRYPTION_KEY!
  const encryptedCredentials = encrypt(JSON.stringify(credentials), encryptionKey)

  // Re-register QStash schedule
  let scheduleId: string | undefined
  try {
    scheduleId = await registerServiceSchedule(id)
  } catch { /* non-fatal */ }

  const { error } = await supabase
    .from('connected_services')
    .update({
      credentials: encryptedCredentials,
      auth_expired: false,
      consecutive_failures: 0,
      ...(scheduleId ? { qstash_schedule_id: scheduleId } : {}),
    })
    .eq('id', id)
    .eq('user_id', user.id)

  if (error) return NextResponse.json({ error: error.message }, { status: 500 })
  return NextResponse.json({ ok: true })
}
```

**Step 2: Create CredentialReauthBanner component**

```typescript
// src/components/credential-reauth-banner.tsx
'use client'

import { useState } from 'react'
import { AlertTriangle } from 'lucide-react'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import type { Credentials } from '@/lib/providers/types'

interface CredentialReauthBannerProps {
  serviceId: string
  providerId: string
  credentialFields: Credentials[]
  onSuccess?: () => void
}

export function CredentialReauthBanner({
  serviceId,
  providerId,
  credentialFields,
  onSuccess,
}: CredentialReauthBannerProps) {
  const [open, setOpen] = useState(false)
  const [values, setValues] = useState<Record<string, string>>({})
  const [saving, setSaving] = useState(false)
  const [error, setError] = useState<string | null>(null)

  async function handleSave() {
    setSaving(true)
    setError(null)
    const res = await fetch(`/api/services/${serviceId}/credentials`, {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ credentials: values, providerId }),
    })
    if (res.ok) {
      onSuccess?.()
      setOpen(false)
    } else {
      const json = await res.json()
      setError(json.error ?? 'Failed to update credentials')
    }
    setSaving(false)
  }

  return (
    <div className="bg-red-950/30 border border-red-800 rounded-lg p-4 mb-6">
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-2 text-red-400">
          <AlertTriangle className="h-4 w-4" />
          <span className="text-sm font-medium">API credentials have expired or are invalid.</span>
        </div>
        <Button
          size="sm"
          variant="outline"
          className="border-red-800 text-red-400 hover:bg-red-950"
          onClick={() => setOpen(!open)}
        >
          {open ? 'Cancel' : 'Update credentials'}
        </Button>
      </div>

      {open && (
        <div className="mt-4 space-y-3">
          {credentialFields.map((field) => (
            <div key={field.key}>
              <Label className="text-xs text-muted-foreground">{field.label}</Label>
              <Input
                type={field.type === 'password' ? 'password' : 'text'}
                placeholder={field.placeholder}
                value={values[field.key] ?? ''}
                onChange={(e) => setValues((v) => ({ ...v, [field.key]: e.target.value }))}
                className="mt-1"
              />
            </div>
          ))}
          {error && <p className="text-xs text-red-400">{error}</p>}
          <div className="flex justify-end gap-2">
            <Button size="sm" onClick={handleSave} disabled={saving}>
              {saving ? 'Saving…' : 'Save & resume monitoring'}
            </Button>
          </div>
        </div>
      )}
    </div>
  )
}
```

**Step 3: Add expired badge to ServiceCard**

In `src/components/service-card.tsx`, add a red "Credentials expired" badge when `authExpired` is true. (ServiceCard already receives this prop.)

**Step 4: Add banner to service detail page**

In `src/app/(app)/dashboard/[serviceId]/page.tsx`, below the header and before `<MetricSection>`:

```typescript
{service.auth_expired && provider && (
  <CredentialReauthBanner
    serviceId={serviceId}
    providerId={service.provider_id}
    credentialFields={provider.credentials}
  />
)}
```

**Step 5: Commit**

```bash
git add src/app/api/services/[id]/credentials/ src/components/credential-reauth-banner.tsx \
        src/components/service-card.tsx "src/app/(app)/dashboard/[serviceId]/page.tsx"
git commit -m "feat: credential re-auth banner and PATCH credentials route"
```

---

## Task 7: Provider — Stripe

**Files:**
- Create: `src/lib/providers/stripe.ts`
- Create: `src/lib/providers/__tests__/stripe.test.ts`
- Modify: `src/lib/providers/index.ts`
- Modify: `src/lib/providers/fetch.ts`

**Step 1: Write the failing test**

```typescript
// src/lib/providers/__tests__/stripe.test.ts
import { describe, it, expect, vi, beforeEach } from 'vitest'

global.fetch = vi.fn()

import { fetchStripeMetrics } from '../stripe'

describe('fetchStripeMetrics', () => {
  beforeEach(() => { vi.resetAllMocks() })

  it('returns account balance', async () => {
    vi.mocked(global.fetch).mockResolvedValue({
      ok: true,
      json: async () => ({ available: [{ amount: 150000, currency: 'usd' }] }),
    } as Response)

    const result = await fetchStripeMetrics('sk_test_xxx')
    expect(result.balance).toBe(1500.00)
    expect(result.status).toBe('healthy')
  })

  it('returns warning when balance < $100', async () => {
    vi.mocked(global.fetch).mockResolvedValue({
      ok: true,
      json: async () => ({ available: [{ amount: 5000, currency: 'usd' }] }),
    } as Response)

    const result = await fetchStripeMetrics('sk_test_xxx')
    expect(result.balance).toBe(50.00)
    expect(result.status).toBe('warning')
  })

  it('returns unknown on API error', async () => {
    vi.mocked(global.fetch).mockResolvedValue({ ok: false, status: 401 } as Response)
    const result = await fetchStripeMetrics('bad-key')
    expect(result.status).toBe('unknown')
  })
})
```

**Step 2: Run to confirm fail**

```bash
npx vitest run src/lib/providers/__tests__/stripe.test.ts
```

**Step 3: Implement**

```typescript
// src/lib/providers/stripe.ts
import type { ServiceProvider } from './types'

export const stripeProvider: ServiceProvider = {
  id: 'stripe',
  name: 'Stripe',
  category: 'payment',
  icon: '/icons/stripe.svg',
  authType: 'api_key',
  credentials: [
    { key: 'apiKey', label: 'Restricted API Key', type: 'password', required: true, placeholder: 'rk_live_...' },
  ],
  collectors: [
    { id: 'account_balance', name: 'Account Balance', metricType: 'currency', unit: 'USD', refreshInterval: 300, endpoint: '/v1/balance' },
  ],
  alerts: [
    { id: 'low-balance', name: 'Low Balance', collectorId: 'account_balance', condition: 'lt', defaultThreshold: 100, message: 'Stripe balance below $100' },
  ],
}

export interface StripeMetricResult {
  balance: number | null
  status: 'healthy' | 'warning' | 'unknown'
  error?: string
}

export async function fetchStripeMetrics(apiKey: string): Promise<StripeMetricResult> {
  try {
    const res = await fetch('https://api.stripe.com/v1/balance', {
      headers: {
        Authorization: `Bearer ${apiKey}`,
      },
    })

    if (!res.ok) return { balance: null, status: 'unknown', error: `HTTP ${res.status}` }

    const json = await res.json()
    const available = json.available as Array<{ amount: number; currency: string }>
    const usd = available.find((a) => a.currency === 'usd')
    const balance = usd ? usd.amount / 100 : 0

    return {
      balance,
      status: balance < 100 ? 'warning' : 'healthy',
    }
  } catch {
    return { balance: null, status: 'unknown', error: 'Network error' }
  }
}
```

**Step 4: Register provider and add to fetch dispatcher**

In `src/lib/providers/index.ts`:
```typescript
import { stripeProvider } from './stripe'
registerProvider(stripeProvider)
export { stripeProvider, fetchStripeMetrics } from './stripe'
```

In `src/lib/providers/fetch.ts`, add case:
```typescript
case 'stripe': {
  const r = await fetchStripeMetrics(credentials.apiKey)
  return [{ collectorId: 'account_balance', value: r.balance ?? null, valueText: null, unit: 'USD', status: r.status }]
}
```

**Step 5: Run tests**

```bash
npx vitest run src/lib/providers/__tests__/stripe.test.ts
```

**Step 6: Commit**

```bash
git add src/lib/providers/stripe.ts src/lib/providers/__tests__/stripe.test.ts \
        src/lib/providers/index.ts src/lib/providers/fetch.ts
git commit -m "feat: add Stripe provider (account balance)"
```

---

## Task 8: Provider — GitHub

Follow the same pattern as Task 7.

**Files:**
- Create: `src/lib/providers/github.ts`
- Create: `src/lib/providers/__tests__/github.test.ts`

**Key implementation details:**

```typescript
// fetchGitHubMetrics(token: string): { minutesUsed, minutesLimit, status }
// Endpoint: GET https://api.github.com/user/settings/billing/actions
// Headers: Authorization: Bearer {token}, X-GitHub-Api-Version: 2022-11-28
// Collectors: actions_minutes_used (count), actions_minutes_limit (count)
// Warning threshold: minutesUsed / minutesLimit > 0.8
// Alert template: Actions usage > 80%
```

**Commit message:** `feat: add GitHub provider (Actions billing minutes)`

---

## Task 9: Provider — Vercel

**Files:**
- Create: `src/lib/providers/vercel.ts`
- Create: `src/lib/providers/__tests__/vercel.test.ts`

**Key implementation details:**

```typescript
// fetchVercelMetrics(token: string): { bandwidthUsed, deploymentStatus, status }
// Endpoint 1: GET https://api.vercel.com/v2/usage  → bandwidth
// Endpoint 2: GET https://api.vercel.com/v6/deployments?limit=1 → latest deployment
// Headers: Authorization: Bearer {token}
// Collectors: bandwidth_used (count, GB), deployment_status (status)
// deployment_status: 'READY' → healthy, 'ERROR' → critical, 'BUILDING' → warning
// Alert templates: Bandwidth > 80 GB, Deployment failed
```

**Commit message:** `feat: add Vercel provider (bandwidth + deployment status)`

---

## Task 10: Provider — OpenAI

**Files:**
- Create: `src/lib/providers/openai.ts`
- Create: `src/lib/providers/__tests__/openai.test.ts`

**Key implementation details:**

```typescript
// fetchOpenAIMetrics(apiKey: string): { creditBalance, monthlyUsage, status }
// Endpoint 1: GET https://api.openai.com/v1/dashboard/billing/credit_grants
// Endpoint 2: GET https://api.openai.com/v1/dashboard/billing/usage?start_date=...&end_date=...
// Collectors: credit_balance (currency), monthly_usage (currency)
// Warning: creditBalance < 5 or monthlyUsage > 50
// Alert templates: Low Credits < $5, High usage > $50
```

**Commit message:** `feat: add OpenAI provider (credit balance + monthly usage)`

---

## Task 11: Provider — Upstash Redis + QStash

**Files:**
- Create: `src/lib/providers/upstash-redis.ts`
- Create: `src/lib/providers/upstash-qstash.ts`
- Create: `src/lib/providers/__tests__/upstash.test.ts`

**Upstash Redis:**

```typescript
// fetchUpstashRedisMetrics(email: string, apiKey: string, databaseId: string)
// Endpoint: GET https://api.upstash.com/v2/redis/stats/{databaseId}
// Auth: Basic base64(email:apiKey)
// Collectors:
//   daily_commands (count) — json.result.dailyrequests
//   memory_usage (percentage) — json.result.used_memory / json.result.maxmemory * 100
// Credentials fields: email, apiKey, databaseId
```

**Upstash QStash:**

```typescript
// fetchUpstashQStashMetrics(token: string)
// Endpoint: GET https://qstash.upstash.io/v2/stats
// Auth: Bearer {token}
// Collectors:
//   messages_delivered (count)
//   messages_failed (count)
//   monthly_quota_used (percentage) — delivered / monthlyLimit * 100
```

**Commit message:** `feat: add Upstash Redis and QStash providers`

---

## Task 12: Connect Page — Category Grouping

**Files:**
- Modify: `src/app/(app)/connect/page.tsx`

Update the connect page to group providers by category:

```typescript
// Group getAllProviders() by category
const CATEGORY_LABELS: Record<string, string> = {
  ai: 'AI / LLM',
  email: 'Email',
  monitoring: 'Monitoring',
  payment: 'Payments',
  hosting: 'DevOps',
  other: 'Infrastructure',
}

// Render each category as a section with a heading
// {Object.entries(grouped).map(([category, providers]) => (
//   <section key={category}>
//     <h2>{CATEGORY_LABELS[category]}</h2>
//     <div className="grid ...">
//       {providers.map(provider => <ProviderCard ... />)}
//     </div>
//   </section>
// ))}
```

**Commit message:** `feat: group connect page providers by category`

---

## Task 13: Realtime Subscriptions — MetricSection + Toast

**Files:**
- Modify: `src/app/(app)/dashboard/[serviceId]/metric-section.tsx`
- Create: `src/components/alert-toast.tsx`
- Modify: `src/app/(app)/layout.tsx`

**Step 1: MetricSection Realtime**

Convert `MetricSection` to subscribe to Supabase Realtime for new metric_snapshots:

```typescript
// At top of MetricSection client component:
import { createClient } from '@/lib/supabase/client'

// Inside component, after initial render:
const [liveSnapshots, setLiveSnapshots] = useState(snapshots)
const supabase = createClient()

useEffect(() => {
  const channel = supabase
    .channel(`snapshots:${serviceId}`)
    .on('postgres_changes', {
      event: 'INSERT',
      schema: 'public',
      table: 'metric_snapshots',
      filter: `connected_service_id=eq.${serviceId}`,
    }, (payload) => {
      setLiveSnapshots((prev) => [...prev, payload.new as Snapshot])
    })
    .subscribe()

  return () => { supabase.removeChannel(channel) }
}, [serviceId])
```

**Step 2: Alert Toast**

Create a lightweight toast component (no new dependencies):

```typescript
// src/components/alert-toast.tsx
'use client'

import { useEffect, useState } from 'react'
import { AlertTriangle } from 'lucide-react'
import { createClient } from '@/lib/supabase/client'

interface ToastMessage {
  id: string
  text: string
}

export function AlertToastContainer() {
  const [toasts, setToasts] = useState<ToastMessage[]>([])
  const supabase = createClient()

  useEffect(() => {
    const channel = supabase
      .channel('alert-events-global')
      .on('postgres_changes', {
        event: 'INSERT',
        schema: 'public',
        table: 'alert_events',
      }, (payload) => {
        const msg: ToastMessage = {
          id: payload.new.id as string,
          text: `Alert triggered`,
        }
        setToasts((t) => [...t, msg])
        setTimeout(() => {
          setToasts((t) => t.filter((x) => x.id !== msg.id))
        }, 5000)
      })
      .subscribe()

    return () => { supabase.removeChannel(channel) }
  }, [])

  if (toasts.length === 0) return null

  return (
    <div className="fixed bottom-4 right-4 space-y-2 z-50">
      {toasts.map((toast) => (
        <div key={toast.id} className="flex items-center gap-2 bg-card border border-amber-800 text-amber-400 rounded-lg px-4 py-3 shadow-lg text-sm">
          <AlertTriangle className="h-4 w-4 shrink-0" />
          {toast.text}
        </div>
      ))}
    </div>
  )
}
```

Add `<AlertToastContainer />` to `src/app/(app)/layout.tsx` inside the main wrapper.

**Step 3: Commit**

```bash
git add src/app/(app)/dashboard/[serviceId]/metric-section.tsx \
        src/components/alert-toast.tsx src/app/(app)/layout.tsx
git commit -m "feat: add Supabase Realtime subscriptions and alert toast"
```

---

## Task 14: Landing Page `/`

**Files:**
- Modify: `src/app/page.tsx`

Replace the Next.js boilerplate with a proper landing page. The page is a server component — check auth and redirect to `/dashboard` if logged in.

```typescript
// src/app/page.tsx
import { redirect } from 'next/navigation'
import Link from 'next/link'
import { createClient } from '@/lib/supabase/server'
import { ProviderIcon } from '@/components/provider-icon'
import { Button } from '@/components/ui/button'

const PROVIDER_LOGOS = ['openrouter', 'resend', 'sentry', 'stripe', 'github', 'vercel', 'openai']

export default async function LandingPage() {
  const supabase = await createClient()
  const { data: { user } } = await supabase.auth.getUser()

  if (user) redirect('/dashboard')

  return (
    <div className="min-h-screen bg-background flex flex-col">
      {/* Nav */}
      <nav className="flex items-center justify-between px-8 py-4 border-b border-border">
        <div className="flex items-center gap-2">
          <span className="w-6 h-6 rounded bg-emerald-500 flex items-center justify-center text-xs font-bold text-white">SP</span>
          <span className="font-semibold text-sm text-foreground">StackPulse</span>
        </div>
        <div className="flex items-center gap-3">
          <Button variant="ghost" size="sm" asChild>
            <Link href="/login">Log in</Link>
          </Button>
          <Button size="sm" asChild>
            <Link href="/login">Get started</Link>
          </Button>
        </div>
      </nav>

      {/* Hero */}
      <main className="flex-1 flex flex-col items-center justify-center text-center px-8 py-24">
        <h1 className="text-4xl font-bold text-foreground mb-4 max-w-lg">
          Monitor all your API services in one place.
        </h1>
        <p className="text-lg text-muted-foreground mb-8 max-w-md">
          Credits, errors, status — get alerted by email before your users notice.
        </p>
        <Button size="lg" asChild>
          <Link href="/login">Connect your first service →</Link>
        </Button>

        {/* Provider logos */}
        <div className="flex items-center gap-4 mt-16 flex-wrap justify-center">
          {PROVIDER_LOGOS.map((id) => (
            <ProviderIcon key={id} providerId={id} size={36} />
          ))}
        </div>
      </main>
    </div>
  )
}
```

**Commit message:** `feat: add landing page with hero and provider logos`

---

## Task 15: Global History Page `/dashboard/history`

**Files:**
- Create: `src/app/(app)/dashboard/history/page.tsx`

Server component. Fetches the first page of events across all user services. Client-side pagination via EventsSection-style load-more.

```typescript
// Route: src/app/(app)/dashboard/history/page.tsx
// Reuses /api/alert-events without serviceId filter (returns all user's events)
// Needs: service filter dropdown, date filter dropdown
// Layout: same max-w-4xl container as service detail page
```

Update `/api/alert-events/route.ts` to support no serviceId (returns all user's events):

```typescript
// If serviceId not provided → fetch all alert_configs for user → get all events
const configsQuery = supabase.from('alert_configs').select('id').eq('user_id', user.id)
// Then filter alert_events by those config IDs
```

**Commit message:** `feat: add /dashboard/history global alert events page`

---

## Task 16: Notification Channels Page `/dashboard/channels`

**Files:**
- Create: `src/app/(app)/dashboard/channels/page.tsx`
- Create: `src/app/api/channels/route.ts`
- Create: `src/app/api/channels/test/route.ts`

**API routes:**

```typescript
// GET /api/channels — list user's notification_channels rows
// POST /api/channels — upsert email channel { type: 'email', config: { email } }
// POST /api/channels/test — send test email via Resend
```

**Page layout:**

```
NOTIFICATION CHANNELS

Email
┌─────────────────────────────────────────────────────┐
│  ● Alerts sent to: dev@example.com       [Edit]     │
│                              [Send test alert]      │
└─────────────────────────────────────────────────────┘

Slack        [Coming soon]
Discord      [Coming soon]
Webhook      [Coming soon]
```

**Commit message:** `feat: add /dashboard/channels notification channels page and API`

---

## Task 17: Sidebar Navigation Update

**Files:**
- Modify: `src/components/app-sidebar.tsx`
- Modify: `src/app/(app)/layout.tsx`

Add History and Channels links below the services list:

```typescript
// Bottom nav section (above Add Service button):
const NAV_ITEMS = [
  { label: 'History', href: '/dashboard/history', icon: Clock },
  { label: 'Channels', href: '/dashboard/channels', icon: Bell },
]

// Active state: pathname === item.href
// Style: same as service items but no status dot/provider badge
```

**Commit message:** `feat: add History and Channels to sidebar navigation`

---

## Task 18: Full Test Suite + Integration Verification

**Step 1: Run full test suite**

```bash
npx vitest run
```

Expected: All tests PASS (target: 80+ tests across 20+ files).

**Step 2: TypeScript check**

```bash
npx tsc --noEmit
```

Expected: Zero errors.

**Step 3: Build check**

```bash
pnpm build
```

Expected: Successful production build.

**Step 4: Manual smoke test**

1. Log in at `http://localhost:4567`
2. Connect a new service → verify QStash schedule registered (check Upstash dashboard)
3. View service detail → wait for next 5-min poll → verify new snapshot appears via Realtime
4. Create an alert rule with a threshold that the current value exceeds → verify email received
5. Navigate to `/dashboard/history` → verify events appear
6. Navigate to `/dashboard/channels` → edit email → send test alert
7. Delete service → verify QStash schedule cancelled

**Step 5: Final commit**

```bash
git add -A
git commit -m "test: phase 2 integration verified, all tests passing"
```

---

## Environment Variables Summary

```bash
# Existing
ENCRYPTION_KEY=...
NEXT_PUBLIC_SUPABASE_URL=...
NEXT_PUBLIC_SUPABASE_ANON_KEY=...
SUPABASE_SERVICE_ROLE_KEY=...
RESEND_API_KEY=...

# New in Phase 2
QSTASH_TOKEN=...
QSTASH_CURRENT_SIGNING_KEY=...
QSTASH_NEXT_SIGNING_KEY=...
NEXT_PUBLIC_APP_URL=https://your-domain.com   # for QStash callbacks + email links
```

---

## Execution Order (Dependencies)

```
Task 1 (deps + migration)
  → Task 2 (alert engine)
  → Task 3 (poll-service worker) — needs Task 2
  → Task 4 (email helper) — needs Resend
  → Task 5 (QStash registration) — needs Task 1
  → Task 6 (credential re-auth) — needs Task 5
  Tasks 7–11 (providers) — independent, can run in parallel
  → Task 12 (connect page grouping) — needs Tasks 7–11
  → Task 13 (realtime) — independent
  → Task 14 (landing page) — independent
  → Task 15 (history page) — independent
  → Task 16 (channels page) — independent
  → Task 17 (sidebar update) — needs Tasks 15, 16
  → Task 18 (final integration) — needs all
```

---

*Plan written by: Claude, 2026-02-18*
